% !TeX root = ./egpaper_final.tex
\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage{cvpr}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}  
\usepackage{amssymb}
\usepackage{caption}
\usepackage{listings}
\usepackage{color}


\usepackage[breaklinks=true,bookmarks=false]{hyperref}

\cvprfinalcopy % *** Uncomment this line for the final submission

\def\cvprPaperID{****} % *** Enter the CVPR Paper ID here
\def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

% Pages are numbered in submission mode, and unnumbered in camera-ready
%\ifcvprfinal\pagestyle{empty}\fi
\setcounter{page}{1}
\begin{document}

\title{Departamento de Ciência da Computação -- Universidade de Brasília (UnB)\\
  Brasília -- DF -- Brasil\\
  Teleinformática e Redes 2 - \\
}

\author{
Manoel Vieira C Neto\\ 
Matrícula 180137816\\
{\tt\small vieiranetoc@gmail.com}
\and
% adicionar os outros
}
\maketitle

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}


\begin{abstract}
  

\end{abstract}
   
\section{Objetivos}
    
%------------------------------------------------------------------------
\section{Introdução}

 
%------------------------------------------------------------------------

%------------------------------------------------------------------------


%------------------------------------------------------------------------

\section{Algoritmo ABR}
O algoritmo foi implementado em python na plataforma PyDash e foi baseado no PANDA\cite{panda}. Esse algoritmo é divido em 4 etapas.

A proposta desse algoritmo é baseado no fato de que nem sempre a taxa de transferência é uma medida justa para o compartilhamento de largura de banda. Desse modo, o algoritmo propõe que sejam feitos pequenos incrementos na banda ao mesmo tempo que se prepara para reduzir a taxa no caso de congestionamentos na rede. Esses incrementos são feitos toda vez que o cliente solicita um novo segmento do vídeo para ser baixado.

\subsection{PyDash}
A implementação do algoritmo depende de como está estruturado o PyDash. Na plataforma, o algoritmo é criado no arquivo r2a\_panda.py com uma classe de nome R2A\_Panda. Essa classe possui os seguintes atributos:

\begin{itemize}
  \item throughputs - é uma lista com a taxa de transferência de todos segmentos obtidos no repositório.
  \item calc\_throughputs - é uma lista com a taxa de transferência alvo de todos os segmentos.
  \item smooth\_throughputs - é uma lista com a taxa de transferência filtrada de todos os segmentos.
  \item request\_time - é utilizado para obter o tempo necessário para que a transferência de um segmento seja feito.
  \item inter\_request\_time - é uma lista contendo o tempo entre a requisição de 2 segmentos consecutivos ou o tempo necessário para a transferência de um segmento, podendo esse tempo ser o real ou o alvo.
  \item qi - é uma lista contendo todas as qualidades disponíveis para ser transferido, obtidas a partir do arquivo mpd.
  \item seg\_duration - é um valor que corresponde ao tamanho de um segmento em segundos.
  \item selected\_qi - é uma lista contendo a qualidade selecionada para cada segmento transferido.
\end{itemize}

A duração de um segmento é um fator importante para definir quais serão transferidos. Desse modo, o valor foi definido para ser sempre de 1s e, consequentemente, o valor de seg\_duration é 1. Os outros valores são obtidos pela aplicação do algoritmo e serão apresentados nas subseções seguintes.

Além dos atributos da classe, os métodos são importantes para o funcionamento adequado e eles são:

\begin{itemize}
  \item handle\_xml\_request - faz a requisição para transferir o arquivo mpd do repositório para o cliente.
  \item handle\_xml\_response - recebe o resultado da requisição do arquivo mpd.
  \item handle\_segment\_size\_request - faz a requisição para transferir um novo segmento do vídeo quando solicitado pelo cliente.
  \item handle\_segment\_size\_response - recebe a resposta da requisição de transferência de um segmento do vídeo.
\end{itemize}


\subsection{Estimativa da banda compartilhada}

A estimativa da banda compartilhada é a primeira etapa do algoritmo.

Normalmente, a taxa de transferência do segmento atual do vídeo (x[n]) é usada para obter o bitrate do segmento que deve ser baixado. Essa taxa pode ser obtida pela seguinte equação:

\begin{equation} \label{actual_throughput}
x[n] = x[n-1] = \frac{r[n-1] \cdot \tau}{T[n-1]} 
\end{equation}

Em que:
\begin{itemize}
  \item n-1 representa o segmento anterior.
  \item n representa o segmento atual.
  \item $\tau$ a duração de um segmento.
  \item r[n-1] representa o bitrate do segmento anterior.
  \item T[n-1] representa o tempo necessário para recuperar do repositório o segmento anterior.
\end{itemize}

Contudo, como nem sempre essa taxa é uma medida justa, o algoritmo determina a taxa média de transferência alvo. Essa taxa, apesar de não representar o valor real na rede, é utilizado para obter o bitrate e também gerenciar o tempo entre as requisições de segmentos. A seguir é apresentada a equação para obter essa taxa:

\begin{equation}\label{target_throughput}
  X[n] = x[n-1] + T[n-1] \cdot k \cdot (w - \max(0, X[n-1] - x[n-1] + w))
\end{equation}

Em que:
\begin{itemize}
 \item $X$ representa a taxa de transferência alvo.
 \item $k$ representa a taxa de convergência de prova.
 \item $w$ representa o incremento de prova do bitrate.
\end{itemize}

Essa equação é implementada no método handle\_segment\_size\_request com o código:

\begin{lstlisting}[language=python]
  x = abs((w - max((0, self.calc_throughputs[-1] - self.throughputs[-1] + w))
  ) * k * self.inter_request_time[-1] + self.calc_throughputs[-1])
\end{lstlisting}

Em que x corresponde a $X[n]$ e os atributos usados com [-1] correspondem ao último elemento de uma lista, no caso os valores obtidos com o segmento anterior. A função abs() é responsável por garantir que não ocorram valores negativos para a taxa obtida.

\subsection{Filtragem da taxa de transferência alvo}
Depois que a taxa é obtida com a equação \ref{target_throughput}, é usada uma função EWMA de suavização de modo a obter uma taxa filtrada y[n]. O objetivo em obter isso, é para não existir anomalias, pontos fora da curva da função. A aplicação dessa função é apresentada a seguir:

\begin{equation} \label{smooth_throughput}
  y[n] = y[n-1] - T[n-1] \cdot \alpha \cdot (y[n-1] - X[n])
\end{equation}

Em que: 
\begin{itemize}
  \item $y[n]$ representa a taxa filtrada para o segmento atual.
  \item $y[n-1]$ representa a taxa filtrada do segmento anterior.
  \item $T[n-1]$ representa o tempo necessário para recuperar do repositório o segmento anterior.
  \item $\alpha$ representa a taxa de convergência da suavização.
  \item $X[n]$ representa a taxa de transferência alvo obtida na equação \ref{target_throughput}.
\end{itemize}

Essa equação é implementada no método handle\_segment\_size\_request da classe com o código:

\begin{lstlisting}[language=python]
  y = abs(-alfa * (self.smooth_throughputs[-1] - x) * self.inter_request_time[-1] + self.smooth_throughputs[-1])
\end{lstlisting}

Em que y corresponde a $y[n]$. A função abs() é responsável por garantir que não ocorram valores negativos para a taxa obtida.

\subsection{Quantizar e identificar bitrate do segmento}

A taxa filtrada é quantizada de modo que possa ser usada para determinar o bitrate. Porém, não é somente feita a quantização, também é aplicada uma função de deadzone para evitar que ocorram saltos entre níveis adjacentes de bitrate. Essa função é feita da seguinte forma:

\begin{equation}
  r[n] = 
  \begin{cases}
    r_{up},       & \quad \text{se } r[n-1] < r_{up}\\
    r[n-1],       & \quad \text{se } r_{up} \leq r[n-1] \leq r_{down} \\
    r_{down},       & \quad \text{caso contrário.}
  \end{cases}
\end{equation}

Em que:
\begin{itemize}
 \item $r_{up}$ corresponde a $y[n] \cdot (1 - \epsilon)$.
 \item $r_{down}$ corresponde a $y[n]$.
 \item $r[n-1]$ corresponde ao bitrate do segmento anterior.
 \item $\epsilon$ corresponde a uma margem de multiplicação.
\end{itemize}

Definido o valor de r[n], é obtido o bitrate disponível mais próximo desse valor. O resultado é o bitrate que será solicitado ao repositório para ser transferido.

Essa função de deadzone e a quantização do bitrate são implementadas no método handle\_segment\_size\_request da classe com o código:

\begin{lstlisting}[language=python]
  selected_rup = self.qi[0]
  selected_rdown = self.qi[0]

  rup = y * (1 - E)
  rdown = y

  for i in self.qi:
      if rup > i:
          selected_rup = i
      if rdown > i:
          selected_rdown = i

  if len(self.selected_qi) == 0:
      self.selected_qi.append(selected_rdown)
  elif self.selected_qi[-1] < selected_rup:
      self.selected_qi.append(selected_rup)
  elif selected_rup <= self.selected_qi[-1] < selected_rdown:
      self.selected_qi.append(self.selected_qi[-1])
  else:
      self.selected_qi.append(selected_rdown)

  msg.add_quality_id(self.selected_qi[-1])
\end{lstlisting}

Em que:
\begin{itemize}
  \item rup corresponde ao $r_{up}$.
  \item rdown corresponde ao $r_{down}$.
  \item selected\_rup corresponde à quantização de $r_{up}$.
  \item selected\_rdown corresponde à quantização de $r_{down}$.
\end{itemize}

A aplicação da equação de deadzone adiciona o bitrate escolhido na lista selected\_qi e, assim, o último elemento da lista é adicionado à mensagem para ser feita a requisição. Após isso, a requisição é feita.

\subsection{Tempo entre requisições de segmentos}
A última etapa do algoritmo consiste em obter o tempo entre requisições alvo, ou seja, não corresponde necessariamente ao tempo que uma transferência é feita, mas quanto tempo seria necessário caso a taxa correspondesse ao alvo ($\hat{T}[n]$). Além disso, o algoritmo propõe a inclusão do tamanho do buffer relacionado a um tamanho mínimo dele nesse tempo de modo que em certas ocasiões o tempo para a próxima requisição possa ser maior se o buffer for superior ao definido como valor mínimo. Isso pode ser observado na seguinte equação:

\begin{equation}
  \hat{T}[n] = \frac{r[n] \cdot \tau}{y[n]} + \beta \cdot (B[n-1] - B_{min})
\end{equation}

Em que:
\begin{itemize}
 \item $\beta$ corresponde à taxa de convergência do buffer do cliente.
 \item $B[n-1]$ corresponde ao buffer do cliente após o recebimento do segmento anterior.
 \item $B_{min}$ corresponde ao tamanho mínimo do buffer.
\end{itemize}

Além disso, também foi calculada a taxa real de transferência ($\tilde{T}[n]$) usando a equação:

\begin{equation}
  \tilde{T}[n] = \frac{r[n] \cdot \tau}{x[n]}
\end{equation}

Com essas duas taxas calculadas, o tempo entre requisições foi definido como:

\begin{equation}
  T[n] = max(\hat{T}[n], \tilde{T}[n])
\end{equation}

Esse é o T[n] utilizado na equação \ref{target_throughput}. Na implementação isso é calculado no método handle\_segment\_size\_response da classe com o código:

\begin{lstlisting}[language=python]
  target_inter_time = msg.get_bit_length() * self.seg_duration / self.calc_throughputs[-1] + beta * (
          B - buffer_min)
  actual_inter_time = time.perf_counter() - self.request_time

  self.inter_request_time.append(max((target_inter_time, actual_inter_time))) 
\end{lstlisting}

Em que:

\begin{itemize}
  \item target\_inter\_time corresponde ao $\hat{T}[n]$.
  \item beta corresponde ao $\beta$.
  \item B corresponde ao tamanho do buffer.
  \item buffer\_min corresponde ao tamanho mínimo do buffer.
  \item actual\_inter\_time corresponde ao $\tilde{T}[n]$.
\end{itemize}

\subsection{Inicialização}
No início do algoritmo alguns valores não estão definidos e por isso eles são determinados antes da aplicação do algoritmo.

A taxa de transferência alvo e a filtrada são iguais à real no momento da inicialização e são obtidas usando o tamanho do arquivo mpd e o tempo necessário para transferir esse arquivo. No código elas são obtidas no método handle\_xml\_response da seguinte forma:

\begin{lstlisting}[language=python]
  if len(self.throughputs) == 0:
    self.throughputs.append(msg.get_bit_length() / t)
    self.calc_throughputs.append(msg.get_bit_length() / t)
    self.smooth_throughputs.append(msg.get_bit_length() / t)
\end{lstlisting}

Como também não há um tamanho para o buffer ainda, o valor usado para obter o tempo alvo entre requisições é obtido com a equação:

\begin{equation}
  B_0 = B_{min} + (1 - \frac{r_0}{X_0}) \cdot \frac{\tau}{\beta}
\end{equation}

Isso é implementado no método handle\_segment\_size\_response da classe com o código:

\begin{lstlisting}[language=python]
  if len(self.throughputs) == 1:
    B = (1 - msg.get_bit_length() /
          self.calc_throughputs[0]) * self.seg_duration / beta + buffer_min
\end{lstlisting}
\section{Resultados}

%------------------------------------------------------------------------

\section{Discussão e Conclusões}

{\small
\bibliographystyle{ieee}
\bibliography{egbib}
}

\end{document}
